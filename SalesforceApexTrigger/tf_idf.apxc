public class tf_idf {
    
    // case number to its description
    static Map<Case, Set<String>> caseToDesc = new Map<Case, Set<String>>();
    
    // pool of old cases' descriptions
    static List<Set<String>> descriptionPool = new List<Set<String>>();
    
    /** 
     * Initialize caseToDesc map and descriptionPool List
     * @param similarCases a collection of cases after the first filter
     */
    public static void initializeVars(Set<Case> similarCases) {
        for (Case oldCase: similarCases) {
            Set<String> parsedDescription = StringHandler.parseAndRemove(oldCase.description);    //fixed
            if (parsedDescription != null) {
            	caseToDesc.put(oldCase, parsedDescription);
            	descriptionPool.add(parsedDescription); 
            }
        }
    }
    
    /** 
     * Return top 5 cases most relevant to the new case in descending order of tfidf value
     * @param keyWordsInDescription a collection of keywords of a new case
     * @param similarCases a collection of cases after the second filter
     * @return a list of cases after application of tfidf algorithm
     */
    public static List<Case> collectOldCases(Set<String> keyWordsInDescription, Set<Case> similarCases) {
        if (similarCases == null || similarCases.isEmpty()) return null;
        tf_idf.initializeVars(similarCases);
        List<caseTfidf> caseTfidfList = new List<caseTfidf>();
        List<Case> oldCases = new List<Case>();
        for (Case currCase: caseToDesc.keySet()) {
            double currTfidf = 0;
        	for (String keyword: keyWordsInDescription) {         
            	currTfidf += tfIdf(caseToDesc.get(currCase), descriptionPool, keyword);
        	}
            caseTfidfList.add(new caseTfidf(currCase, currTfidf));
        }
        caseTfidfList.sort();
        
        //return top 5 relevant cases based on their tfidf value (can change a maximum number of old cases)
        Integer numCases = 5;
        for (Integer i = 0; i < numCases && i < caseTfidfList.size(); i++) {
            oldCases.add(caseTfidfList.get(i).cs);
            System.debug(logginglevel.error, 'case number: ' + caseTfidfList.get(i).cs.casenumber + 
                         ', tfidf value: ' + caseTfidfList.get(i).tfidf);
        }
        return oldCases;
    }

    /**
     * @param doc  list of strings
     * @param term String represents a term
     * @return term frequency of term in document
     */
    public static double tf(Set<String> doc, String term) {
        double result = 0;
        for (String word : doc) {
            if (term.equalsIgnoreCase(word))
                result++;
        }
        Integer denom = 1;
        if (doc.size() != 0) denom = doc.size(); 
        return result / denom;
    }

    /**
     * @param docs list of set of strings represents the dataset
     * @param term String represents a term
     * @return the inverse term frequency of term in documents
     */
    public static double idf(List<Set<String>> docs, String term) {
        double n = 0;
        for (Set<String> doc : docs) {
            for (String word : doc) {
                if (term.equalsIgnoreCase(word)) {
                    n++;
                    break;
                }
            }
        }
        if (n == 0) n = 1;
        return Math.log(docs.size() / n);
    }

    /**
     * @param doc  a text document
     * @param docs all documents
     * @param term term
     * @return the TF-IDF of term
     */
    public static double tfIdf(Set<String> doc, List<Set<String>> docs, String term) {
        return tf_idf.tf(doc, term) * tf_idf.idf(docs, term);
    }
    
}